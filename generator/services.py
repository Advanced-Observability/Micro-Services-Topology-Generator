"""
Service generated by MSTG.
"""

from string import Template

import os

import utils
import entities
import constants
import kubernetes


class Service(entities.Entity):
    """Represent a microservice in the architecture."""

    def __init__(self, name: str, entity, external: bool, image_name: str):
        super().__init__(name, None)

        self.external = external
        self.image_name = image_name

        if not self.external:
            self.ports = [entity["port"]]
        else:
            self.ports = entity["ports"]

        # Port exposed by default
        if "expose" in entity:
            self.expose = entity["expose"]
        else:
            self.expose = True

    def __str__(self) -> str:
        return f"Service: {self.name} - ports: {self.ports} - external: {self.external} "\
            f"- image_name = {self.image_name} - {super().__str__()}"

    def pretty(self) -> str:
        return f"Service: {self.name}"\
            f"\n\t- ports: {self.ports}"\
            f"\n\t- external: {self.external}"\
            f"\n\t- image: {self.image_name}"\
            f"\n\t- {super().pretty()}"

    def export_commands(self, compose: bool) -> str:
        """Generate one line combining all commands."""

        if utils.output_is_k8s():
            # need to drop icmp redirect (type 5) to prevent modification of the routing
            self.commands.append(constants.DROP_ICMP_REDIRECT)

        if utils.is_using_ioam_only() or utils.is_using_clt():
            self.commands.append(constants.ADD_IOAM_NAMESPACE)
            if not self.external:
                self.commands.append(constants.LAUNCH_INTERFACE_SCRIPT)
            else:
                self.commands.append(constants.CMD_INLINE_SYSCTL.format(self.ioam_id))

        if utils.is_using_clt():
            self.commands.append(constants.LAUNCH_IOAM_AGENT)

        self.commands.append(constants.DELETE_DEFAULT_IPV4_ROUTE)
        self.commands.append(constants.DELETE_DEFAULT_IPV6_ROUTE)

        if not self.external:
            self.commands.append(constants.LAUNCH_SERVICE)

        if compose:
            return self.cmds_combined()[:-1]

        return self.cmds_combined(True)[:-1]

    def export_compose(self, file) -> None:
        """Export the service in the given docker compose file."""

        if self.external:
            mappings = {
                "name": self.name,
                "dockerImage": self.image_name
            }
            file.write(constants.EXTERNAL_TEMPLATE.substitute(mappings))

            with open(constants.COMMANDS_FILE, "a", encoding="utf-8") as f:
                f.write(constants.TEMPLATE_CMD.format(self.name, self.export_commands(True)))
                f.write("\n")
        else:
            # write template
            mappings = {
                "name": self.name,
                "commands": self.export_commands(True),
                "CLT_ENABLE": os.environ[constants.CLT_ENABLE_ENV],
                "IOAM_ENABLE": os.environ[constants.IOAM_ENABLE_ENV],
                "JAEGER_ENABLE": os.environ[constants.JAEGER_ENABLE_ENV],
                "HTTP_VER": os.environ[constants.HTTP_VER_ENV],
                "IP_VERSION": os.environ[constants.IP_VERSION_ENV],
                "dockerImage": self.image_name,
            }
            file.write(constants.SERVICE_TEMPLATE.substitute(mappings))

            # if using https => add key + cert
            if utils.topology_is_https():
                file.write(f"      - CERT_FILE={constants.PATH_CERTIFICATE}\n")
                file.write(f"      - KEY_FILE={constants.PATH_KEY_FILE}\n")

        if self.expose:
            file.write("    ports:\n")
            for port in self.ports:
                file.write(f"     - {port}:{port}\n")

        # sysctl configuration
        if utils.is_using_clt() or utils.is_using_ioam_only():
            file.write("    sysctls:")
            file.write(
                Template(constants.COMPOSE_SYSCTL_DEFAULTS).substitute({"ioam_id": self.ioam_id})
            )

        # depends_on
        self.export_compose_depends_on(file)

        # write networks
        self.export_compose_networks(file)

        # write extra hosts to prevent conflict in dns
        if len(self.extra_hosts) > 0:
            file.write("    extra_hosts:\n")
            for host in self.extra_hosts:
                file.write(f"      - \"{host[0]}:{host[1]}\"\n")

    def export_compose_networks(self, file) -> None:
        """Export network settings in Docker compose."""

        # no network to attach
        if len(self.attached_networks) == 0 and not utils.is_using_jaeger():
            return

        file.write("    networks:\n")

        if utils.is_using_jaeger():
            file.write("      network_telemetry:\n")

        for i in range(len(self.attached_networks)):
            if utils.topology_is_ipv4():
                file.write(constants.COMPOSE_IPV4_NET_SPEC.substitute({
                    "net_name": self.attached_networks[i]["name"],
                    "ip": str(self.attached_networks[i]["ip"]),
                    "ifname": utils.get_interface_name(i, self.name)
                }))
            else:
                file.write(constants.COMPOSE_IPV6_NET_SPEC.substitute({
                    "net_name": self.attached_networks[i]["name"],
                    "ip": str(self.attached_networks[i]["ip"]),
                    "ifname": utils.get_interface_name(i, self.name)
                }))

    def export_compose_depends_on(self, file) -> None:
        """Export depends on in Docker compose."""

        # no dependence
        if len(self.depends_on) == 0 and not (utils.is_using_clt() or utils.is_using_jaeger()):
            return

        file.write("    depends_on:\n")

        if utils.is_using_jaeger():
            file.write("      - jaeger\n")
        if utils.is_using_clt():
            file.write("      - ioam-collector\n")
        for dependency in self.depends_on:
            file.write(f"      - {dependency}\n")

    def export_k8s(self):
        """Export the service to Kubernetes configuration files."""

        self.export_k8s_pod()
        self.export_k8s_service()

    def export_k8s_pod(self):
        """Export the service to a Kubernetes pod."""

        ports = ""
        for port in self.ports:
            ports += Template(constants.K8S_POD_PORT).substitute({"port": port})
            ports += "\n"

        cmd = ""
        if not self.external:
            cmd = constants.K8S_POD_CMD.format(self.export_commands(False))
        else:
            with open(constants.COMMANDS_FILE, "a", encoding="utf-8") as f:
                cmds = self.export_commands(False)
                f.write(constants.TEMPLATE_CMD_KUBECTL.format(f"{self.name}-pod", cmds))
                f.write("\n")

        # pod configuration
        pod_config = {
            "name": f"{self.name}-pod",
            "serviceName": f"{self.name}-svc",
            "shortName": self.name,
            "image": self.image_name,
            "cmd": cmd,
            "CLT_ENABLE": f"\"{os.environ[constants.CLT_ENABLE_ENV]}\"",
            "JAEGER_HOSTNAME": constants.K8S_JAEGER_HOSTNAME,
            "JAEGER_ENABLE": f"\"{os.environ[constants.JAEGER_ENABLE_ENV]}\"",
            "COLLECTOR_HOSTNAME": constants.K8S_COLLECTOR_HOSTNAME,
            "HTTP_VER": os.environ[constants.HTTP_VER_ENV],
            "CERT_FILE": "empty",
            "KEY_FILE": "empty",
            "IP_VERSION": f"\"{os.environ[constants.IP_VERSION_ENV]}\"",
            "ports": ports
        }

        if utils.topology_is_https():
            pod_config["CERT_FILE"] = constants.PATH_CERTIFICATE
            pod_config["KEY_FILE"] = constants.PATH_KEY_FILE

        pod = constants.TEMPLATE_K8S_POD.substitute(pod_config)

        # output file
        f = open(
            os.path.join(constants.K8S_EXPORT_FOLDER, f"{self.name}_pod.yaml"),
            "w", encoding="utf-8"
        )
        f.write(pod)

        # write sysctls
        if utils.is_using_clt() or utils.is_using_ioam_only():
            f.write(Template(constants.K8S_SYSCTL_DEFAULTS).substitute({"ioam_id": self.ioam_id}))

        # write extra hosts
        if len(self.extra_hosts) > 0:
            f.write("  hostAliases:")
            for host in self.extra_hosts:
                f.write(f"""
    - ip: \"{host[1]}\"
      hostnames:
      - \"{host[0]}\"""")

        f.close()

    def export_k8s_service(self):
        """Export the service to a Kubernetes service."""

        ports = ""
        for port in self.ports:
            ports += Template(constants.K8S_SERVICE_PORT).substitute(
                {"port": port, "nodePort": kubernetes.Kubernetes.next_node_port()}
            )
            ports += "\n"

        service_config = {
            "name": f"{self.name}-svc",
            "podName": f"{self.name}-pod",
            "ports": ports
        }
        service = constants.TEMPLATE_K8S_SERVICE.substitute(service_config)
        with open(
            os.path.join(constants.K8S_EXPORT_FOLDER, f"{self.name}_service.yaml"),
            "w", encoding="utf-8"
        ) as f:
            f.write(service)
