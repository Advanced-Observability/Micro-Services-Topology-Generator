"""
Service generated by MSTG.
"""

from string import Template

import os

import utils
import network
import entities
import constants
import kubernetes


class Service(entities.Entity):
    """Represent a microservice in the architecture."""

    def __init__(self, name: str, config, external: bool, image_name: str):
        """
        Create a microservice.

        :param name: Name of the microservice.
        :param config: Loaded YAML configuration of the service.
        :param external: Using external container image.
        :param image_name: Name of the Docker image to use.
        """
        super().__init__(name, config, None)

        self.external = external
        self.image_name = image_name

        if not self.external:
            self.ports = [config["port"]]
        else:
            self.ports = config["ports"]

        # Port exposed by default
        if "expose" in config:
            self.expose = config["expose"]
        else:
            self.expose = True

    def __str__(self) -> str:
        return (
            f"Service: {self.name} - ports: {self.ports} - external: {self.external} "
            f"- image_name = {self.image_name} - {super().__str__()}"
        )

    def pretty(self) -> str:
        return (
            f"Service: {self.name}"
            f"\n\t- ports: {self.ports}"
            f"\n\t- external: {self.external}"
            f"\n\t- image: {self.image_name}"
            f"\n\t- {super().pretty()}"
        )

    def export_commands(self) -> str:
        """Generate one line combining all commands."""

        if utils.output_is_k8s():
            # need to drop icmp redirect (type 5) to prevent modification of the routing
            self.add_command(constants.DROP_ICMP_REDIRECT)

        if utils.is_using_ioam_only() or utils.is_using_clt():
            self.add_command(constants.ADD_IOAM_NAMESPACE)
            if not self.external:
                self.add_command(constants.LAUNCH_INTERFACE_SCRIPT)
            else:
                self.add_command(constants.CMD_INLINE_SYSCTL.format(self.ioam_id))

        if utils.is_using_clt():
            self.add_command(constants.LAUNCH_IOAM_AGENT)

        self.add_command(constants.DELETE_DEFAULT_IPV4_ROUTE)
        self.add_command(constants.DELETE_DEFAULT_IPV6_ROUTE)

        return utils.combine_commands(list(self.commands), "&")

    def export_compose(self, file) -> None:
        """Export the service in the given docker compose file."""

        if self.external:
            mappings = {"name": self.name, "dockerImage": self.image_name}
            file.write(constants.EXTERNAL_TEMPLATE.substitute(mappings))
        else:
            # write template
            mappings = {
                "name": self.name,
                "commands": utils.export_single_command(constants.LAUNCH_SERVICE),
                "CLT_ENABLE": os.environ[constants.CLT_ENABLE_ENV],
                "IOAM_ENABLE": os.environ[constants.IOAM_ENABLE_ENV],
                "JAEGER_ENABLE": os.environ[constants.JAEGER_ENABLE_ENV],
                "HTTP_VER": os.environ[constants.HTTP_VER_ENV],
                "IP_VERSION": os.environ[constants.IP_VERSION_ENV],
                "dockerImage": self.image_name,
            }
            file.write(constants.SERVICE_TEMPLATE.substitute(mappings))

            # if using https => add key + cert
            if utils.topology_is_https():
                file.write(f"      - CERT_FILE={constants.PATH_CERTIFICATE}\n")
                file.write(f"      - KEY_FILE={constants.PATH_KEY_FILE}\n")

        if self.expose:
            file.write("    ports:\n")
            for port in self.ports:
                file.write(f"     - {port}:{port}\n")

        # sysctl configuration
        if utils.is_using_clt() or utils.is_using_ioam_only():
            file.write("    sysctls:")
            file.write(
                Template(constants.COMPOSE_SYSCTL_DEFAULTS).substitute(
                    {"ioam_id": self.ioam_id}
                )
            )

        # depends_on
        self.export_compose_depends_on(file)

        # write networks
        self.export_compose_networks(file)

        # write extra hosts to prevent conflict in dns
        if len(self.extra_hosts) > 0:
            file.write("    extra_hosts:\n")
            for host, ip in self.extra_hosts.items():
                file.write(f'      - "{host}:{ip}"\n')

        # export commands
        self.export_commands()
        self.generate_commands_file()

    def export_compose_networks(self, file) -> None:
        """Export network settings in Docker compose."""

        # no network to attach
        if self.count_l3_networks() == 0 and not utils.is_using_jaeger():
            return

        file.write("    networks:\n")

        if utils.is_using_jaeger():
            file.write("      network_telemetry:\n")

        for i, net in enumerate(self.attached_networks):
            # do not attach L2 network. Will be configured with veth
            if net.type == network.NetworkType.L2_NET:
                continue

            name = net.name
            ip = net.get_entity_ip(self.name)
            mac = net.get_entity_mac(self.name)
            ifname = utils.get_interface_name(i, self.name)

            mappings = {"net_name": name, "ip": ip, "mac": mac, "ifname": ifname}

            if utils.topology_is_ipv4():
                file.write(constants.COMPOSE_IPV4_NET_SPEC.substitute(mappings))
            else:
                file.write(constants.COMPOSE_IPV6_NET_SPEC.substitute(mappings))

    def export_compose_depends_on(self, file) -> None:
        """Export depends on in Docker compose."""

        # no dependence
        if len(self.depends_on) == 0 and not (
            utils.is_using_clt() or utils.is_using_jaeger()
        ):
            return

        file.write("    depends_on:\n")

        if utils.is_using_jaeger():
            file.write("      - jaeger\n")
        if utils.is_using_clt():
            file.write("      - ioam-collector\n")
        for dependency in self.depends_on:
            file.write(f"      - {dependency}\n")

    def export_k8s(self):
        """Export the service to Kubernetes configuration files."""

        self.export_k8s_pod()
        self.export_k8s_service()

    def export_k8s_pod(self):
        """Export the service to a Kubernetes pod."""

        ports = ""
        for port in self.ports:
            ports += Template(constants.K8S_POD_PORT).substitute({"port": port})

        cmd = ""
        if not self.external:
            cmd = constants.K8S_POD_CMD.format(
                self.export_commands()
                + f" & {utils.export_single_command(constants.LAUNCH_SERVICE)}"
            )
        else:
            with open(constants.COMMANDS_FILE, "a", encoding="utf-8") as f:
                cmds = self.export_commands()
                f.write(constants.KUBECTL_CMD.format(f"{self.name}-pod", cmds) + " &")
                f.write("\n")

        # pod configuration
        pod_config = {
            "name": f"{self.name}-pod",
            "serviceName": f"{self.name}-svc",
            "shortName": self.name,
            "image": self.image_name,
            "cmd": cmd,
            "CLT_ENABLE": f'"{os.environ[constants.CLT_ENABLE_ENV]}"',
            "JAEGER_HOSTNAME": constants.K8S_JAEGER_HOSTNAME,
            "JAEGER_ENABLE": f'"{os.environ[constants.JAEGER_ENABLE_ENV]}"',
            "COLLECTOR_HOSTNAME": constants.K8S_COLLECTOR_HOSTNAME,
            "HTTP_VER": os.environ[constants.HTTP_VER_ENV],
            "CERT_FILE": "empty",
            "KEY_FILE": "empty",
            "IP_VERSION": f'"{os.environ[constants.IP_VERSION_ENV]}"',
            "ports": ports,
        }

        if utils.topology_is_https():
            pod_config["CERT_FILE"] = constants.PATH_CERTIFICATE
            pod_config["KEY_FILE"] = constants.PATH_KEY_FILE

        pod = constants.TEMPLATE_K8S_POD.substitute(pod_config)

        # output file
        f = open(
            os.path.join(constants.K8S_EXPORT_FOLDER, f"{self.name}_pod.yaml"),
            "w",
            encoding="utf-8",
        )
        f.write(pod)

        # write sysctls
        if utils.is_using_clt() or utils.is_using_ioam_only():
            f.write(
                Template(constants.K8S_SYSCTL_DEFAULTS).substitute(
                    {"ioam_id": self.ioam_id}
                )
            )

        # write extra hosts
        if len(self.extra_hosts) > 0:
            f.write("  hostAliases:")
            for host, ip in self.extra_hosts.items():
                f.write(f"""
    - ip: \"{ip}\"
      hostnames:
      - \"{host}\"""")

        f.close()

    def export_k8s_service(self):
        """Export the service to a Kubernetes service."""

        ports = ""
        for port in self.ports:
            ports += Template(constants.K8S_SERVICE_PORT).substitute(
                {"port": port, "nodePort": kubernetes.Kubernetes.next_node_port()}
            )

        service_config = {
            "name": f"{self.name}-svc",
            "podName": f"{self.name}-pod",
            "ports": ports,
        }
        service = constants.TEMPLATE_K8S_SERVICE.substitute(service_config)
        with open(
            os.path.join(constants.K8S_EXPORT_FOLDER, f"{self.name}_service.yaml"),
            "w",
            encoding="utf-8",
        ) as f:
            f.write(service)
