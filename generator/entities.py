"""
Entities generated by the generator.
"""

from string import Template

import os
import ipaddress

import kubernetes
import utils
import constants


class DockerNetwork:
    """Represent a Docker network"""

    # used to generate the ip subnets
    # start at 1 because the first network will be used for telemetry.
    network_counter = 1

    def __init__(self, begin: str, end: str):
        self.begin = begin
        self.end = end
        self.name = DockerNetwork.generate_name(begin, end)

        self.network_id = DockerNetwork.network_counter + 1
        DockerNetwork.network_counter += 1

        self.network: ipaddress.IPv4Network | ipaddress.IPv6Network
        if utils.output_is_k8s() and utils.topology_is_ipv4():
            self.network = utils.convert_network_id_to_k8s_ipv4(self.network_id)
        elif utils.output_is_k8s() and utils.topology_is_ipv6():
            self.network = utils.convert_network_id_to_k8s_ipv6(self.network_id)
        elif utils.output_is_compose() and utils.topology_is_ipv4():
            self.network = utils.convert_network_id_to_ip4_network(self.network_id)
        elif utils.output_is_compose() and utils.topology_is_ipv6():
            self.network = utils.convert_network_id_to_ip6_network(self.network_id)

        self.subnet = self.network.with_prefixlen
        hosts = iter(self.network.hosts())
        self.gateway = next(hosts) if utils.output_is_compose() else None
        self.begin_ip = next(hosts)
        self.end_ip = next(hosts)

    def __str__(self) -> str:
        return f"Docker network {self.name} - Subnet: {self.subnet} - Gateway: {self.gateway} - "\
            f"Begin: {self.begin} (IP: {self.begin_ip}) - End: {self.end} (IP: {self.end_ip}) - "\
                f"ID: {self.network_id}"

    def pretty(self) -> str:
        """Indented string describing the object"""
        return f"Docker network {self.name}\n\t- Subnet: {self.subnet}\n\t- Gateway: "\
            f"{self.gateway}\n\t- Begin: {self.begin} (IP: {self.begin_ip})\n\t- End: {self.end} "\
                f"(IP: {self.end_ip})\n\t- ID: {self.network_id}"

    def export_compose(self, file) -> None:
        """Export the Docker network in the given docker compose file."""
        mappings = dict(name=self.name, subnet=self.subnet, gateway=self.gateway)
        if utils.topology_is_ipv4():
            file.write(constants.NETWORK_IPV4_TEMPLATE.substitute(mappings))
        else:
            file.write(constants.NETWORK_IPV6_TEMPLATE.substitute(mappings))

    @staticmethod
    def generate_name(begin: str, end: str) -> str:
        """Generate name for Docker network shared by `begin` and `end`."""
        return constants.NETWORK_NAME.format(begin, end)


class Entity:
    """Represent every entity in the architecture."""

    # used to assign a unique IOAM id to every entity
    ioam_counter = 0

    def __init__(self, name: str, kubernetes_ip):
        self.name = name
        self.ioam_id = Entity.ioam_counter + 1
        Entity.ioam_counter += 1
        self.kubernetes_ip = kubernetes_ip

        # docker networks to which the entity is attached
        self.attached_networks: list[dict] = []
        # list of names of entities on which the current one depends
        # used by docker compose to start the containers in the appropriate order
        self.depends_on: set[str] = set()
        # ip route commands to configure the networking of the entity
        self.iproute_cmds: set[str] = set()
        # additional commands to configure the entity
        self.additional_cmds: list[str] = []

    def __str__(self) -> str:
        return f"Entity: {self.name} - ioam_id: {self.ioam_id} - kubernetes IP: "\
            f"{self.kubernetes_ip} - networks: {self.attached_networks} - depends-on: "\
                f"{self.depends_on} - iproute configuration: {self.iproute_to_str(False)} - "\
                    f"additional commands: {self.commands_to_str(False)}"

    def pretty(self) -> str:
        """Indented string describing the object"""
        return f"Entity: {self.name}\n\t\t- ioam_id: {self.ioam_id}\n\t\t- kubernetes IP: "\
            f"{self.kubernetes_ip}\n\t\t- networks: {self.attached_networks}\n\t\t- depends-on: "\
                f"{self.depends_on}\n\t\t- iproute configuration:"\
                    f"\n{self.iproute_to_str(True)}\n\t\t- additional "\
                        f"commands:{self.commands_to_str(True)}"

    def iproute_to_str(self, pretty: bool = False) -> str:
        """Convert ip route commands to str."""
        cmds_str = ""
        for cmd in self.iproute_cmds:
            if pretty:
                cmds_str += f"\t\t\t- {str(cmd)}\n"
            else:
                cmds_str += f",{str(cmd)}"
        return cmds_str

    def commands_to_str(self, pretty: bool = False) -> str:
        """Convert commands to str."""
        cmds_str = ""
        for cmd in self.additional_cmds:
            if pretty:
                cmds_str += f"\n\t\t\t- {str(cmd)}"
            else:
                cmds_str += f",{str(cmd)}"
        return cmds_str

    def get_network_pos(self, name: str) -> int | None:
        """
        Get id of attached network with given `name`.
        If not found, return None.
        """

        for net in self.attached_networks:
            if net["name"] == name:
                return self.attached_networks.index(net)

        return None


class Service(Entity):
    """Represent a microservice in the architecture."""

    def __init__(self, name: str, entity):
        super().__init__(name, None)

        self.port = entity["port"]

        # Port exposed by default
        if "expose" in entity:
            self.expose = entity["expose"]
        else:
            self.expose = True

        # end-to-end connections
        self.e2e_conns: list[str] = []
        # hosts to which the entity is connected to in end-to-end connections
        self.extra_hosts: set[tuple[str, ipaddress.IPv4Address | ipaddress.IPv6Address]] = set()

    def __str__(self) -> str:
        return f"Service: {self.name} - port: {self.port} - e2e connections: {self.e2e_to_str()} "\
            f"- {super().__str__()}"

    def pretty(self) -> str:
        return f"Service: {self.name}\n\t- port: {self.port}\n\t- e2e connections: "\
            f"{self.e2e_to_str()}\n\t- extra hosts: {self.extra_hosts}\n\t- {super().pretty()}"

    def e2e_to_str(self) -> str:
        """Convert end-to-end connections to string."""
        e2e = ""
        for e2econn in self.e2e_conns:
            e2e += f"{e2econn},"
        return e2e

    def export_compose(self, file) -> None:
        """Export the service in the given docker compose file."""

        # generate one line combining all extra commands
        additional_cmds = ""
        for cmd in self.iproute_cmds:
            additional_cmds += f"({cmd}) & "
        for cmd in self.additional_cmds:
            additional_cmds += f"({cmd}) & "
        if utils.is_using_ioam_only() or utils.is_using_clt():
            additional_cmds+="(sh set_interfaces.sh) & "

        image = "mstg_service" if not utils.is_using_clt() else "mstg_service_clt"

        # write template
        mappings = dict(
            name=self.name, ioam_id=self.ioam_id,
            additional_cmds=additional_cmds,
            CLT_ENABLE=os.environ[constants.CLT_ENABLE_ENV],
            IOAM_ONLY=os.environ[constants.IOAM_ENABLE_ENV],
            dockerImage=image, JAEGER_ENABLE=os.environ[constants.JAEGER_ENABLE_ENV],
            HTTP_VER=os.environ[constants.HTTP_VER_ENV],
            IOAM_ENABLE=os.environ[constants.IOAM_ENABLE_ENV]
        )
        if utils.topology_is_ipv4():
            file.write(constants.SERVICE_IPV4_TEMPLATE.substitute(mappings))
        else:
            file.write(constants.SERVICE_IPV6_TEMPLATE.substitute(mappings))

        if self.expose:
            file.write("    ports:\n")
            file.write(f"     - {self.port}:{self.port}\n")

        # if using https => add key + cert
        if utils.topology_is_https():
            file.write(f"      - CERT_FILE={constants.PATH_CERTIFICATE}\n")
            file.write(f"      - KEY_FILE={constants.PATH_KEY_FILE}\n")

        # sysctl configuration
        if utils.is_using_clt() or utils.is_using_ioam_only():
            file.write("    sysctls:")
            file.write(
                Template(constants.COMPOSE_SYSCTL_DEFAULTS).substitute({"ioam_id": self.ioam_id})
            )

        # depends_on
        already_wrote = False
        if utils.is_using_jaeger() or utils.is_using_clt():
            already_wrote = True
            file.write("    depends_on:\n")
        if utils.is_using_jaeger():
            file.write("      - jaeger\n")
        if utils.is_using_clt():
            file.write("      - ioam-collector\n")
        if not already_wrote and len(self.depends_on) > 0:
            file.write("    depends_on:\n")
        for dependency in self.depends_on:
            file.write(f"      - {dependency}\n")

        # write networks
        wrote_header = False
        if utils.is_using_jaeger():
            wrote_header = True
            file.write("    networks:\n")
            file.write("      network_telemetry:\n")
        if len(self.attached_networks) > 0 and not wrote_header:
            file.write("    networks:\n")
        for i in range(len(self.attached_networks)):
            file.write(f"      {self.attached_networks[i]["name"]}:\n")
            if utils.topology_is_ipv4():
                file.write(f"        ipv4_address: {str(self.attached_networks[i]["ip"])}\n")
                file.write(f"        driver_opts:\n")
                file.write(f"          com.docker.network.endpoint.ifname: eth{i}_{self.name}\n")
            else:
                file.write(f"        ipv6_address: {str(self.attached_networks[i]["ip"])}\n")
                file.write(f"        driver_opts:\n")
                file.write(f"          com.docker.network.endpoint.ifname: eth{i}_{self.name}\n")

        # write extra hosts to prevent conflict in dns
        if len(self.extra_hosts) > 0:
            file.write("    extra_hosts:\n")
            for host in self.extra_hosts:
                file.write(f"      - \"{host[0]}:{host[1]}\"\n")

    def export_k8s(self):
        """Export the service to Kubernetes configuration files."""

        self.export_k8s_pod()
        self.export_k8s_service()

    def export_k8s_pod(self):
        """Export the service to a Kubernetes pod."""

        # generate oneline combining all commands
        # need to drop icmp redirect (type 5) to prevent modification of the routing
        oneline_cmd = f"({constants.DROP_ICMP_REDIRECT}) & "
        oneline_cmd += f"({constants.ADD_IOAM_NAMESPACE}) & "
        for cmd in self.iproute_cmds:
            # sleep to be sure that interfaces had time to be configured properly by meshnet cni
            oneline_cmd += f"(sleep 20 && {cmd}) & "
        for cmd in self.additional_cmds:
            oneline_cmd += f"(sleep 20 && {cmd}) & "
        if utils.is_using_ioam_only() or utils.is_using_clt():
            oneline_cmd += "(sleep 20 && sh set_interfaces.sh) & "
        oneline_cmd += "(/usr/local/bin/service /etc/config.yml)"
        # add ioam agent is using clt
        if utils.is_using_clt():
            oneline_cmd += "& (/ioam-agent -i eth0)"
        cmd=f"""
        - sh
        - -c
        - {oneline_cmd}
"""

        image = "mstg_service" if not utils.is_using_clt() else "mstg_service_clt"

        # pod configuration
        pod_config = dict(
            name=f"{self.name}-pod", serviceName=f"{self.name}-svc", shortName=self.name,
            image=image, cmd=cmd, CLT_ENABLE=f"\"{os.environ[constants.CLT_ENABLE_ENV]}\"",
            JAEGER_HOSTNAME=constants.K8S_JAEGER_HOSTNAME,
            JAEGER_ENABLE=f"\"{os.environ[constants.JAEGER_ENABLE_ENV]}\"",
            COLLECTOR_HOSTNAME=constants.K8S_COLLECTOR_HOSTNAME,
            HTTP_VER=os.environ[constants.HTTP_VER_ENV], CERT_FILE="empty", KEY_FILE="empty",
            IP_VERSION=f"\"{os.environ[constants.IP_VERSION_ENV]}\"", port=self.port
        )

        if utils.topology_is_https():
            pod_config["CERT_FILE"] = constants.PATH_CERTIFICATE
            pod_config["KEY_FILE"] = constants.PATH_KEY_FILE

        pod = constants.TEMPLATE_K8S_POD.substitute(pod_config)

        # output file
        f = open(f"{constants.K8S_EXPORT_FOLDER}/{self.name}_pod.yaml", "w", encoding="utf-8")
        f.write(pod)

        # write sysctls
        if utils.is_using_clt() or utils.is_using_ioam_only():
            f.write(Template(constants.K8S_SYSCTL_DEFAULTS).substitute({"ioam_id": self.ioam_id}))

        # write extra hosts
        if len(self.extra_hosts) > 0:
            f.write("  hostAliases:")
            for host in self.extra_hosts:
                f.write(f"""
    - ip: \"{host[1]}\"
      hostnames:
      - \"{host[0]}\"""")

        f.close()

    def export_k8s_service(self):
        """Export the service to a Kubernetes service."""

        node_port = kubernetes.Kubernetes.next_node_port()
        service_config = dict(
            name=f"{self.name}-svc", podName=f"{self.name}-pod",
            port=self.port, node_port=node_port
        )
        service = constants.TEMPLATE_K8S_SERVICE.substitute(service_config)
        f = open(f"{constants.K8S_EXPORT_FOLDER}/{self.name}_service.yaml", "w", encoding="utf-8")
        f.write(service)
        f.close()


class Router(Entity):
    """Represent a router in the architecture."""

    def __init__(self, name: str):
        super().__init__(name, None)

    def __str__(self) -> str:
        return f"Router: {self.name} - {super().__str__()}"

    def pretty(self) -> str:
        """Indented string describing the object"""
        return f"Router: {self.name}\n\t- {super().pretty()}"

    def export_compose(self, file) -> None:
        """Export the service in the given docker compose file."""

        # generate one line combining all extra commands
        additional_cmds = ""
        for cmd in self.iproute_cmds:
            additional_cmds += f"({cmd}) & "
        for cmd in self.additional_cmds:
            additional_cmds += f"({cmd}) & "
        if utils.is_using_ioam_only() or utils.is_using_clt():
            additional_cmds += "(sh set_interfaces.sh) & "

        image = "mstg_router" if not utils.is_using_clt() else "mstg_router_clt"

        # write template
        mappings = dict(
            name=self.name, ioam_id=self.ioam_id, additional_cmds=additional_cmds,
            CLT_ENABLE=os.environ[constants.CLT_ENABLE_ENV],
            IOAM_ONLY=os.environ[constants.IOAM_ENABLE_ENV], dockerImage=image
        )
        if utils.topology_is_ipv4():
            file.write(constants.ROUTER_IPV4_TEMPLATE.substitute(mappings))
        else:
            file.write(constants.ROUTER_IPV6_TEMPLATE.substitute(mappings))

        # sysctl configuration
        if utils.is_using_clt() or utils.is_using_ioam_only():
            file.write(
                Template(constants.COMPOSE_SYSCTL_DEFAULTS).substitute({"ioam_id": self.ioam_id})
            )

        # depends_on
        if len(self.depends_on) > 0:
            file.write("    depends_on:\n")
            for dependency in self.depends_on:
                file.write(f"      - {dependency}\n")

        # write networks
        file.write("    networks:\n")
        for i in range(len(self.attached_networks)):
            file.write(f"      {self.attached_networks[i]["name"]}:\n")
            if utils.topology_is_ipv4():
                file.write(f"        ipv4_address: {str(self.attached_networks[i]["ip"])}\n")
                file.write(f"        driver_opts:\n")
                file.write(f"          com.docker.network.endpoint.ifname: eth{i}_{self.name}\n")
            else:
                file.write(f"        ipv6_address: {str(self.attached_networks[i]["ip"])}\n")
                file.write(f"        driver_opts:\n")
                file.write(f"          com.docker.network.endpoint.ifname: eth{i}_{self.name}\n")

    def export_k8s(self):
        """Export the router to Kubernetes configuration files."""

        port = kubernetes.Kubernetes.next_node_port()
        self.export_k8s_pod(port)
        self.export_k8s_service(port)

    def export_k8s_pod(self, port: int):
        """Export the router to a Kubernetes pod using the given `port`."""

        # generate one line combining all commands
        # need to drop icmp redirect (type 5) to prevent modification of the routing
        oneline_cmd = f"({constants.DROP_ICMP_REDIRECT}) & "
        oneline_cmd += f"({constants.ADD_IOAM_NAMESPACE}) & "
        for cmd in self.iproute_cmds:
            # sleep to be sure that interfaces had time to be configured properly by meshnet cni
            oneline_cmd += f"(sleep 20 && {cmd}) & "
        for cmd in self.additional_cmds:
            oneline_cmd += f"(sleep 20 && {cmd}) & "
        if utils.is_using_ioam_only() or utils.is_using_clt():
            oneline_cmd += "(sleep 20 && sh set_interfaces.sh) & "

        oneline_cmd += ("(tail -f /dev/null)")
        cmd=f"""
        - sh
        - -c
        - {oneline_cmd}
"""
        image = "mstg_router" if not utils.is_using_clt() else "mstg_router_clt"

        # pod configuration
        pod_config = dict(
            name=f"{self.name}-pod", serviceName=f"{self.name}-svc", shortName=self.name,
            image=image, cmd=cmd, CLT_ENABLE=f"\"{os.environ[constants.CLT_ENABLE_ENV]}\"",
            JAEGER_HOSTNAME=constants.K8S_JAEGER_HOSTNAME,
            JAEGER_ENABLE=f"\"{os.environ[constants.JAEGER_ENABLE_ENV]}\"",
            COLLECTOR_HOSTNAME=constants.K8S_COLLECTOR_HOSTNAME,
            HTTP_VER=os.environ[constants.HTTP_VER_ENV], CERT_FILE="empty", KEY_FILE="empty",
            IP_VERSION=f"\"{os.environ[constants.IP_VERSION_ENV]}\"", port=port
        )
        pod = constants.TEMPLATE_K8S_POD.substitute(pod_config)

        # output file
        f = open(f"{constants.K8S_EXPORT_FOLDER}/{self.name}_pod.yaml", "w", encoding="utf-8")
        f.write(pod)

        # write sysctls
        if utils.is_using_clt() or utils.is_using_ioam_only():
            f.write(Template(constants.K8S_SYSCTL_DEFAULTS).substitute({"ioam_id": self.ioam_id}))

        f.close()

    def export_k8s_service(self, port: int):
        """Export the router to a Kubernetes service using the given `port`."""

        service_config = dict(
            name=f"{self.name}-svc", podName=f"{self.name}-pod", port=port, node_port=port
        )
        service = constants.TEMPLATE_K8S_SERVICE.substitute(service_config)
        f = open(f"{constants.K8S_EXPORT_FOLDER}/{self.name}_service.yaml", "w", encoding="utf-8")
        f.write(service)
        f.close()
